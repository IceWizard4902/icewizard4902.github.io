# dceased-xxiv

A Misc category, but Crypto related challenge. We are given three pictures `out.png` and `part.png`, where it seems like `part.png` is leaking a bit of `out.png`. 

We are also given what seems like the Python script for the encryption of the original file 

```python
from PIL import Image
import random, time

def xor(a):
	return a[0] ^ a[1]

def xor_tuple(a, b):
	return tuple(i for i in map(xor, zip(*[a, b])))

def rgba2int(rgba: tuple):
	ret = 0
	for i in range(3, -1, -1):
		ret += rgba[i] << 8*(3 - i)
	return ret

def int2rgba(n):
	r, g, b, a = tuple([(n >> 8*i) & 0xff for i in range(3, -1, -1)])
	return (r, g, b, a)

img = Image.open('flag.png')

random.seed(time.time())

px = img.load()
x_len, y_len = img.size

new = Image.new('RGBA', (x_len, y_len), 'white')
px1 = new.load()

for y in range(y_len):
	for x in range(x_len):
		rand = random.getrandbits(32)
		rr, rg, rb, ra = int2rgba(rand)
		r, g, b, a = px[x, y]
		new_pix = xor_tuple((rr, rg, rb, ra), (r, g, b, a))
		px1[x, y] = new_pix

new.save('out.png')
```

What the script basically does is to `xor` the RGB values of each pixel in the original file `flag.png` with the random number (actually the converted representation of the number into a tuple of `(a, b, c)`) and write the RGB values of the encrypted pixel to `out.png`. 

We can take advantage of the fact that the `random` module of Python uses Mersenne Twister, in particular, `MT19937`, which is reversible. The `random` module in Python does not provide a cryptographically secure pseudorandom number generator (PRNG), as the output generation of `MT19937` is a reversible operation. Hence, an attacker, with enough bits observed from the PRNG, can clone the PRNG itself, or in other words, obtain the exact value of the seed in use. More on this can be found by [The Book of Gehn](https://book-of-gehn.github.io/articles/2018/12/23/Mersenne-Twister-PRNG.html) and the Cryptopals writeup from [cedricvanrompay](https://cedricvanrompay.gitlab.io/cryptopals/challenges/23.html).

There are implementations to break the `random` module used in Python. One such tool is [randcrack](https://github.com/tna0y/Python-random-module-cracker). Two crucial things to note: first, `randcrack` only needs 624 bits to obtain the value of the seed; second, after inputting `624` bits of the PRNG to `randcrack`, we generate the pseudorandom values generated from the guessed out seed of `random` by doing `rc.predict_getrandbits(32)` - it will start generating the next 32 bits after the initial 624.

The idea of the script is to use the few pixels that is leaked in `part.png`, `xor`-ing with the encrypted pixels in `out.png`, we should get the random values used. Supplying about 624 bits to `randcrack`, we should be able to clone the PRNG and output the future values generated by the PRNG.

Solution Implementation:
```python
from PIL import Image
from randcrack import RandCrack
import random 
from tqdm import tqdm 

rc = RandCrack()

def xor(a):
	return a[0] ^ a[1]

def xor_tuple(a, b):
	return tuple(i for i in map(xor, zip(*[a, b])))

def rgba2int(rgba: tuple):
	ret = 0
	for i in range(3, -1, -1):
		ret += rgba[i] << 8 * (3 - i)
	return ret

def int2rgba(n):
	r, g, b, a = tuple([(n >> 8*i) & 0xff for i in range(3, -1, -1)])
	return (r, g, b, a)

part = Image.open('part.png')
out = Image.open('out.png')

px_part = part.load()
px_out = out.load()

x_len, y_len = part.size 

for y in range(1):
    for x in range(x_len - 96):
        part_r, part_g, part_b, part_a = px_part[x, y]
        out_r, out_g, out_b, out_a = px_out[x, y]

        key = xor_tuple((part_r, part_g, part_b, part_a), (out_r, out_g, out_b, out_a))
        key = rgba2int(key)
        rc.submit(key)

new = Image.new('RGBA', (x_len, y_len), 'white')
px_flag = new.load()

for y in tqdm(range(y_len)):
    for x in range(x_len):
        if (y == 0 and x in range(x_len - 96)):
            continue
        rand = rc.predict_getrandbits(32)
        rr, rg, rb, ra = int2rgba(rand)
        r, g, b, a = px_part[x, y]
        new_pix = xor_tuple((rr, rg, rb, ra), (r, g, b, a))
        px_flag[x, y] = new_pix

new.save('flag.png')
```

The image after running the Python script should hold the flag.

<img src="./flag.png" style="display:block;margin-left:auto;margin-right:auto">